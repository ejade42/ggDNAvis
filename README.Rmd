---
output: 
    bookdown::github_document2:
        number_sections: true
        toc: true
        toc_depth: 3
---

# ggDNAvis

ggDNAvis is an R package that uses ggplot2 to visualise genetic data of three main types:

(1) a single DNA/RNA sequence split across multiple lines,

(2) multiple DNA/RNA sequences, each occupying a whole line, or

(3) base modifications such as DNA methylation called by modified-bases models in Dorado or Guppy.

This is accomplished through main functions `visualise_single_sequence()`, `visualise_many_sequences()`, and `visualise_methylation()` respectively. Each of these has helper sequences for streamlined data processing, as detailed later in the section for each visualisation type.

Additionally, ggDNAvis contains a built-in example dataset (`example_many_sequences`) and a set of colour palettes for DNA visualisation (`sequence_colour_palettes`).

Note that all spellings are the British English version (e.g. "colour", "visualise"). Aliases have not been defined, meaning American spellings will not work.

Throughout this manual, only ggDNAvis and its dependecies (including the full namespaces of dplyr and ggplot2) are loaded:

```{r}
library(ggDNAvis)
library(dplyr)
```

# Loading data

## Introduction to `example_many_sequences`
ggDNAvis comes with example dataset `example_many_sequences`. In this data, each row/observation represents one read. Reads are associated with metadata such as the participant and family to which they belong, and with sequence data such as the DNA sequence, FASTQ quality scores, and modification information retrieved from the MM and ML tags in a SAM/BAM file.

```{r}
## View the first 4 rows of example_many_sequences data
knitr::kable(head(example_many_sequences, 4))
```

The DNA sequence in column `sequence` is the information used for visualising single/multiple sequences. For visualising DNA modification, this data contains information on both 5-cytosine-methylation and 5-cytosine-hydroxymethylation. For a given modification type (e.g. methylation), visualisation requires a column of locations and a column of probabilities. In this dataset, the relevant columns are `methylation_locations` and `methylation_probabilities` for methylation and `hydroxymethylation_locations` and `hydroxymethylation_probabilities` for hydroxymethylation.

Locations are stored as a comma-condensed string of integers for each read, produced via `vector_to_string()`, and indicate the indices along the read at which the probability of modification was assessed. For example, methylation might be assessed at each CpG site, which in the read `"GGCGGCGGAGGCGGCGGA"` would be the third, sixth, twelfth, and fifteenth bases, thus the location string would be `"3,6,12,15"` for that read.

Probabilities are also a comma-condensed string of integers produced via `vector_to_string()`, but here each integer represents the probability that the corresponding base is modified. Probabilities are stored as 8-bit integers (0-255) where a score of $N$ represents the probability space from $\frac{N}{256}$ to $\frac{N+1}{256}$. For the read above, a probability string of `"250,3,50,127"` would indicate that the third base is almost certainly methylated (97.66%-98.05%), the sixth base is almost certainly not methylated (1.17%-1.56%), the twelfth base is most likely not methylated (19.53%-19.92%), and the fifteenth base may or may not be methylated (49.61%-50.00%)

```{r}
## Function to convert integer scores to corresponding percentages
convert_8bit_to_decimal_prob <- function(x) {
    return(c(  x   / 256, 
             (x+1) / 256))
}

## Convert comma-condensed string back to numerical vector
## string_to_vector() and vector_to_string() are crucial ggDNAvis helpers
probabilities <- string_to_vector("250,3,50,127")

## For each probability, print 8-bit score then percentage range
for (probability in probabilities) {
    percentages <- round(convert_8bit_to_decimal_prob(probability), 4) * 100
    cat("8-bit probability: ", probability, "\n", sep = "")
    cat("Decimal probability: ", percentages[1], "% - ", percentages[2], "%", "\n\n", sep = "")
}
```



## Loading from FASTQ and metadata file

### Standard FASTQ

To read in a normal FASTQ file (containing a read ID/header, sequence, and quality scores for each read), the function `read_fastq()` can be used. The example data file for this is `inst/extdata/example_many_sequences_raw.fastq`

```{r}
## Load data from FASTQ
fastq_data <- read_fastq("inst/extdata/example_many_sequences_raw.fastq", calculate_length = TRUE)

## View first 4 rows
knitr::kable(head(fastq_data, 4))
```
Using the basic `read_fastq()` function returns a dataframe with read ID, sequence, and quality columns. Optionally, a sequence_length column can be generated by setting `calculate_length = TRUE`. However, we can see that some of the sequences e.g. F1-1c are reversed. This occurs when the read is of the - strand at the biochemical level. 

To convert reverse reads to their forward equivalents, and incorporate additional data such as the participant and family to which each read belongs, we will make use of a metadata file located at `inst/extdata/example_many_sequences_metadata.csv`

```{r}
## Load metadata from CSV
metadata <- read.csv("inst/extdata/example_many_sequences_metadata.csv")

## View first 4 rows
knitr::kable(head(metadata, 4))
```

We see that this metadata file contains the same `read` column with the same unique read IDs and a `direction` column specifying whether each read is `"forward"` or `"reverse"`. These two columns are mandatory. Additionally, we have family and participant ID columns providing additional information on each read.

Note: the `direction` column can be produced manually. However, for large data volumes it may be more effective to use SAMtools to write TXT files of all forward and reverse read IDs via the -F/-f 16 flags, e.g.:

```{bash, eval = FALSE}
## bash/shell code for using SAMtools on the command line:

## See the samtools flag documentation for more details on why
## -F 16 selects forward reads and -F 16 selects reverse reads
samtools view -F 16 ${input_bam_file} | \
awk '{print $1}'  > "forward_reads.fastq"

samtools view -f 16 ${input_bam_file} | \
awk '{print $1}'  > "reverse_reads.fastq"
```

Then simply read the lines from each file and use that to assign directions:

```{r, eval = FALSE}
## Use files from last step to construct vectors of forward and reverse IDs
forward_reads <- readLines("forward_reads.fastq")
reverse_reads <- readLines("reverse_reads.fastq")

## Use rep() to add a direction column
constructed_metadata <- data.frame(
    read = c(forward_reads, reverse_reads),
    direction = c(rep("forward", length(forward_reads)),
                  rep("reverse", length(reverse_reads)))
    )
```

In any case, once we have metadata with the `read` and `direction` columns, we can use `merge_fastq_with_metadata()` to combine the metadata and the fastq data. Crucially, this function uses the `direction` column of the metadata to determine which reads are reverse, and reverse-complements these reverse reads only to produce a new column containing the forward version of all reads:

```{r}
## Merge fastq data with metadata
## This function reverse-complements reverse reads to get all forward versions
merged_fastq_data <- merge_fastq_with_metadata(fastq_data, metadata)

## View first 4 rows
knitr::kable(head(merged_fastq_data, 4))
```

Now we have a `forward_sequence` column (scroll to the right if you can't see it!). We can now reformat this data to be exactly the same as the included `example_many_sequences` data:

```{r}
## Subset to only the columns present in example_many_sequences
merged_fastq_data <- merged_fastq_data[, c("family", "individual", "read", "forward_sequence", "sequence_length", "forward_quality")]

## Rename "forward_sequence" to "sequence" and same for quality
colnames(merged_fastq_data)[c(4,6)] <- c("sequence", "quality")

## View first 4 rows of data produced from files
knitr::kable(head(merged_fastq_data, 4))

## View first 4 rows of example_many_sequences (with modification columns excluded)
knitr::kable(head(example_many_sequences[, 1:6], 4))

## Check if equal
identical(merged_fastq_data, example_many_sequences[, 1:6])
```

So, from just a standard FASTQ file and a simple metadata CSV we have successfully reproduced the example_many_sequences data (excluding methylation/modification information) via `read_fastq()` and `merge_fastq_with_metadata()`. We can also write from this dataframe to FASTQ using `write_fastq()`:

```{r, eval = FALSE}
output_fastq <- write_fastq()
```

# Visualising a single DNA/RNA sequence

ggDNAvis can be used to visualise a single DNA sequence via `visualise_single_sequence`
